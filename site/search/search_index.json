{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MacNotesApp Work with Apple MacOS Notes.app from the command line. Also includes python interface for scripting Notes.app from your own python code. Interactive browsing of notes in a TUI (Terminal User Interface? Textual User Interface?) coming soon! For full documentation visit macnotesapp . Installation If you just want to use the command line tool, the easiest option is to install via pipx . If you use pipx , you will not need to create a python virtual environment as pipx takes care of this. The easiest way to do this on a Mac is to use homebrew : Open Terminal (search for Terminal in Spotlight or look in Applications/Utilities ) Install homebrew according to instructions at https://brew.sh/ Type the following into Terminal: brew install pipx Then type this: pipx install macnotesapp pipx will install the macnotesapp command line interface (CLI) as an executable named notes Now you should be able to run notes by typing: notes Once you've installed macnotesapp with pipx, to upgrade to the latest version: pipx upgrade macnotesapp Note : Currently tested on MacOS 10.15.7/Catalina and 13.1/Ventura.","title":"Home"},{"location":"#welcome-to-macnotesapp","text":"Work with Apple MacOS Notes.app from the command line. Also includes python interface for scripting Notes.app from your own python code. Interactive browsing of notes in a TUI (Terminal User Interface? Textual User Interface?) coming soon! For full documentation visit macnotesapp .","title":"Welcome to MacNotesApp"},{"location":"#installation","text":"If you just want to use the command line tool, the easiest option is to install via pipx . If you use pipx , you will not need to create a python virtual environment as pipx takes care of this. The easiest way to do this on a Mac is to use homebrew : Open Terminal (search for Terminal in Spotlight or look in Applications/Utilities ) Install homebrew according to instructions at https://brew.sh/ Type the following into Terminal: brew install pipx Then type this: pipx install macnotesapp pipx will install the macnotesapp command line interface (CLI) as an executable named notes Now you should be able to run notes by typing: notes Once you've installed macnotesapp with pipx, to upgrade to the latest version: pipx upgrade macnotesapp Note : Currently tested on MacOS 10.15.7/Catalina and 13.1/Ventura.","title":"Installation"},{"location":"cli/","text":"Command Line Reference notes notes: work with Apple Notes on the command line. Usage: notes [OPTIONS] COMMAND [ARGS]... Options: -v, --version Show the version and exit. --help Show this message and exit. accounts Print information about Notes accounts. Usage: notes accounts [OPTIONS] Options: -j, --json Print output in JSON format. --help Show this message and exit. add Add new note. There are multiple ways to add a new note: Add a new note from standard input (STDIN): notes add cat file.txt | notes add notes add < file.txt Add a new note by passing string on command line: notes add NOTE Add a new note by opening default editor (defined in $EDITOR or via notes config ): notes add --edit notes add -e Add a new note from URL (downloads URL, creates a cleaned readable version to store in new Note): notes add --url URL notes add -u URL If NOTE is a single line, adds new note with name NOTE and no body. If NOTE is more than one line, adds new note where name is first line of NOTE and body is remainder. Body of note must be plain text unless --html/-h or --markdown/-m flag is set in which case body should be HTML or Markdown, respectively. If --edit/-e flag is set, note will be opened in default editor before being added. If --show/-s flag is set, note will be shown in Notes.app after being added. Account and top level folder may be specified with --account/-a and --folder/-f, respectively. If not provided, default account and folder are used. Usage: notes add [OPTIONS] NOTE Options: -s, --show Show note in Notes after adding. -F, --file FILENAME -u, --url URL -h, --html Use HTML for body of note. -m, --markdown Use Markdown for body of note. -p, --plaintext Use plaintext for body of note (default unless changed in `notes config`). -e, --edit Edit note text before adding in default editor. -a, --account ACCOUNT Add note to account ACCOUNT. -f, --folder FOLDER Add note to folder FOLDER. --help Show this message and exit. cat Print one or more notes to STDOUT Usage: notes cat [OPTIONS] NOTE_NAME Options: -p, --plaintext Output note as plain text. -m, --markdown Output note as Markdown. -h, --html Output note as HTML. -j, --json Output note as JSON. The default format for the note body in JSON is HTML (this is how the note is stored in Notes). If --plaintext or --markdown is also specified, the note body in the resulting JSON will be in the specified format. --help Show this message and exit. config Configure default settings for account, editor, etc. Usage: notes config [OPTIONS] Options: --help Show this message and exit. dump Dump all notes or selection of notes for debugging Usage: notes dump [OPTIONS] Options: -s, --selected Dump only selected notes. -B, --no-body Do not dump note body. --help Show this message and exit. help Print help; for help on commands: help . Usage: notes help [OPTIONS] [TOPIC] [SUBTOPIC] Options: --help Show this message and exit. list List notes, optionally filtering by account or text. Usage: notes list [OPTIONS] TEXT Options: -a, --account ACCOUNT Limit results to account ACCOUNT; may be repeated to include multiple accounts. --help Show this message and exit.","title":"Command Line Reference"},{"location":"cli/#command-line-reference","text":"","title":"Command Line Reference"},{"location":"cli/#notes","text":"notes: work with Apple Notes on the command line. Usage: notes [OPTIONS] COMMAND [ARGS]... Options: -v, --version Show the version and exit. --help Show this message and exit.","title":"notes"},{"location":"cli/#accounts","text":"Print information about Notes accounts. Usage: notes accounts [OPTIONS] Options: -j, --json Print output in JSON format. --help Show this message and exit.","title":"accounts"},{"location":"cli/#add","text":"Add new note. There are multiple ways to add a new note: Add a new note from standard input (STDIN): notes add cat file.txt | notes add notes add < file.txt Add a new note by passing string on command line: notes add NOTE Add a new note by opening default editor (defined in $EDITOR or via notes config ): notes add --edit notes add -e Add a new note from URL (downloads URL, creates a cleaned readable version to store in new Note): notes add --url URL notes add -u URL If NOTE is a single line, adds new note with name NOTE and no body. If NOTE is more than one line, adds new note where name is first line of NOTE and body is remainder. Body of note must be plain text unless --html/-h or --markdown/-m flag is set in which case body should be HTML or Markdown, respectively. If --edit/-e flag is set, note will be opened in default editor before being added. If --show/-s flag is set, note will be shown in Notes.app after being added. Account and top level folder may be specified with --account/-a and --folder/-f, respectively. If not provided, default account and folder are used. Usage: notes add [OPTIONS] NOTE Options: -s, --show Show note in Notes after adding. -F, --file FILENAME -u, --url URL -h, --html Use HTML for body of note. -m, --markdown Use Markdown for body of note. -p, --plaintext Use plaintext for body of note (default unless changed in `notes config`). -e, --edit Edit note text before adding in default editor. -a, --account ACCOUNT Add note to account ACCOUNT. -f, --folder FOLDER Add note to folder FOLDER. --help Show this message and exit.","title":"add"},{"location":"cli/#cat","text":"Print one or more notes to STDOUT Usage: notes cat [OPTIONS] NOTE_NAME Options: -p, --plaintext Output note as plain text. -m, --markdown Output note as Markdown. -h, --html Output note as HTML. -j, --json Output note as JSON. The default format for the note body in JSON is HTML (this is how the note is stored in Notes). If --plaintext or --markdown is also specified, the note body in the resulting JSON will be in the specified format. --help Show this message and exit.","title":"cat"},{"location":"cli/#config","text":"Configure default settings for account, editor, etc. Usage: notes config [OPTIONS] Options: --help Show this message and exit.","title":"config"},{"location":"cli/#dump","text":"Dump all notes or selection of notes for debugging Usage: notes dump [OPTIONS] Options: -s, --selected Dump only selected notes. -B, --no-body Do not dump note body. --help Show this message and exit.","title":"dump"},{"location":"cli/#help","text":"Print help; for help on commands: help . Usage: notes help [OPTIONS] [TOPIC] [SUBTOPIC] Options: --help Show this message and exit.","title":"help"},{"location":"cli/#list","text":"List notes, optionally filtering by account or text. Usage: notes list [OPTIONS] TEXT Options: -a, --account ACCOUNT Limit results to account ACCOUNT; may be repeated to include multiple accounts. --help Show this message and exit.","title":"list"},{"location":"reference/","text":"Reference NotesApp Represents Notes.app instance Source code in macnotesapp/notesapp.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 class NotesApp : \"\"\"Represents Notes.app instance\"\"\" def __init__ ( self ): \"\"\"create new NotesApp object\"\"\" self . _app = ScriptingBridge . SBApplication . applicationWithBundleIdentifier_ ( \"com.apple.Notes\" ) @property def app ( self ): \"\"\"Return Notes.app SBApplication object\"\"\" return self . _app @property def accounts ( self ) -> list [ str ]: \"\"\"Return list of accounts\"\"\" return [ str ( a . name ()) for a in self . _app . accounts ()] @property def default_account ( self ) -> str : \"\"\"Return name of default account\"\"\" return str ( self . _app . defaultAccount () . name ()) def notes ( self , name : list [ str ] | None = None , body : list [ str ] | None = None , text : list [ str ] | None = None , password_protected : bool | None = None , id : list [ str ] | None = None , accounts : list [ str ] | None = None , ) -> list [ \"Note\" ]: \"\"\"Return Note object for all notes contained in Notes.app or notes filtered by property. Args: name: list of note names to filter by body: list of note bodies to filter by text: list of note text to filter by password_protected: filter by password protected notes id: list of note ids to filter by accounts: list of account names to filter by Returns: list of Note objects \"\"\" # TODO: should this be a generator? account_list = self . app . accounts () if accounts : format_str = \"name == %@\" + \" OR name == %@ \" * ( len ( accounts ) - 1 ) predicate = AppKit . NSPredicate . predicateWithFormat_ ( format_str , accounts ) account_list = account_list . filteredArrayUsingPredicate_ ( predicate ) notes = [] for account in account_list : notes . extend ( Account ( account ) . notes ( name , body , text , password_protected , id ) ) return notes def noteslist ( self , name : list [ str ] | None = None , body : list [ str ] | None = None , text : list [ str ] | None = None , password_protected : bool | None = None , id : list [ str ] | None = None , accounts : list [ str ] | None = None , ) -> \"NotesList\" : \"\"\"Return NoteList object for all notes contained in account or notes filtered by property. Args: name: list of note names to filter by body: list of note bodies to filter by text: list of note text to filter by password_protected: filter by password protected notes id: list of note ids to filter by accounts: list of account names to filter by Returns: NotesList object \"\"\" account_list = self . app . accounts () if accounts : format_str = \"name == %@\" + \" OR name == %@ \" * ( len ( accounts ) - 1 ) predicate = AppKit . NSPredicate . predicateWithFormat_ ( format_str , accounts ) account_list = account_list . filteredArrayUsingPredicate_ ( predicate ) noteslists = [ Account ( account ) . _noteslist ( name = name , body = body , text = text , password_protected = password_protected , id = id , ) for account in account_list ] return NotesList ( * noteslists ) @property def selection ( self ) -> list [ \"Note\" ]: \"\"\"Return lit of Note objects for selected notes\"\"\" notes = self . app . selection () return [ Note ( note ) for note in notes ] @property def version ( self ) -> str : \"\"\"Return version of Notes.app\"\"\" return str ( self . app . version ()) def make_note ( self , name : str , body : str , attachments : list [ str ] | None = None ) -> \"Note\" : \"\"\"Create new note in default folder of default account. Args: name: name of notes body: body of note as HTML text attachments: optional list of paths to attachments to add to note Returns: newly created Note object \"\"\" # reference: https://developer.apple.com/documentation/scriptingbridge/sbobject/1423973-initwithproperties account = Account ( self . app . defaultAccount ()) note = account . make_note ( name , body ) if attachments : for attachment in attachments : note . add_attachment ( attachment ) return note def account ( self , account : Optional [ str ] = None ) -> \"Account\" : \"\"\"Return Account object for account or default account if account is None. Arg: account: name of account to return. If None, return default account. Returns: Account object \"\"\" account = account or self . default_account predicate = AppKit . NSPredicate . predicateWithFormat_ ( \"name == %@\" , account ) accounts = self . app . accounts () . filteredArrayUsingPredicate_ ( predicate ) if not accounts : raise ValueError ( f \"Could not find account { account } \" ) account_obj = accounts [ 0 ] return Account ( account_obj ) def activate ( self ) -> None : \"\"\"Activate Notes.app\"\"\" run_script ( \"notesActivate\" ) def quit ( self ) -> None : \"\"\"Quit Notes.app\"\"\" run_script ( \"notesQuit\" ) def __len__ ( self ) -> int : \"\"\"Return count of notes in Notes.app\"\"\" return sum ( len ( account . notes ()) for account in self . app . accounts ()) def __iter__ ( self ) -> Generator [ \"Note\" , None , None ]: \"\"\"Generator to yield Note object for all notes contained in Notes.app\"\"\" for account in self . app . accounts (): notes = account . notes () for note in notes : yield Note ( note ) accounts : list [ str ] property Return list of accounts app property Return Notes.app SBApplication object default_account : str property Return name of default account selection : list [ 'Note' ] property Return lit of Note objects for selected notes version : str property Return version of Notes.app __init__ () create new NotesApp object Source code in macnotesapp/notesapp.py 56 57 58 59 60 def __init__ ( self ): \"\"\"create new NotesApp object\"\"\" self . _app = ScriptingBridge . SBApplication . applicationWithBundleIdentifier_ ( \"com.apple.Notes\" ) __iter__ () Generator to yield Note object for all notes contained in Notes.app Source code in macnotesapp/notesapp.py 212 213 214 215 216 217 def __iter__ ( self ) -> Generator [ \"Note\" , None , None ]: \"\"\"Generator to yield Note object for all notes contained in Notes.app\"\"\" for account in self . app . accounts (): notes = account . notes () for note in notes : yield Note ( note ) __len__ () Return count of notes in Notes.app Source code in macnotesapp/notesapp.py 208 209 210 def __len__ ( self ) -> int : \"\"\"Return count of notes in Notes.app\"\"\" return sum ( len ( account . notes ()) for account in self . app . accounts ()) account ( account = None ) Return Account object for account or default account if account is None. Arg account: name of account to return. If None, return default account. Returns: Type Description 'Account' Account object Source code in macnotesapp/notesapp.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def account ( self , account : Optional [ str ] = None ) -> \"Account\" : \"\"\"Return Account object for account or default account if account is None. Arg: account: name of account to return. If None, return default account. Returns: Account object \"\"\" account = account or self . default_account predicate = AppKit . NSPredicate . predicateWithFormat_ ( \"name == %@\" , account ) accounts = self . app . accounts () . filteredArrayUsingPredicate_ ( predicate ) if not accounts : raise ValueError ( f \"Could not find account { account } \" ) account_obj = accounts [ 0 ] return Account ( account_obj ) activate () Activate Notes.app Source code in macnotesapp/notesapp.py 200 201 202 def activate ( self ) -> None : \"\"\"Activate Notes.app\"\"\" run_script ( \"notesActivate\" ) make_note ( name , body , attachments = None ) Create new note in default folder of default account. Parameters: Name Type Description Default name str name of notes required body str body of note as HTML text required attachments list [ str ] | None optional list of paths to attachments to add to note None Returns: Type Description 'Note' newly created Note object Source code in macnotesapp/notesapp.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def make_note ( self , name : str , body : str , attachments : list [ str ] | None = None ) -> \"Note\" : \"\"\"Create new note in default folder of default account. Args: name: name of notes body: body of note as HTML text attachments: optional list of paths to attachments to add to note Returns: newly created Note object \"\"\" # reference: https://developer.apple.com/documentation/scriptingbridge/sbobject/1423973-initwithproperties account = Account ( self . app . defaultAccount ()) note = account . make_note ( name , body ) if attachments : for attachment in attachments : note . add_attachment ( attachment ) return note notes ( name = None , body = None , text = None , password_protected = None , id = None , accounts = None ) Return Note object for all notes contained in Notes.app or notes filtered by property. Parameters: Name Type Description Default name list [ str ] | None list of note names to filter by None body list [ str ] | None list of note bodies to filter by None text list [ str ] | None list of note text to filter by None password_protected bool | None filter by password protected notes None id list [ str ] | None list of note ids to filter by None accounts list [ str ] | None list of account names to filter by None Returns: Type Description list ['Note'] list of Note objects Source code in macnotesapp/notesapp.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def notes ( self , name : list [ str ] | None = None , body : list [ str ] | None = None , text : list [ str ] | None = None , password_protected : bool | None = None , id : list [ str ] | None = None , accounts : list [ str ] | None = None , ) -> list [ \"Note\" ]: \"\"\"Return Note object for all notes contained in Notes.app or notes filtered by property. Args: name: list of note names to filter by body: list of note bodies to filter by text: list of note text to filter by password_protected: filter by password protected notes id: list of note ids to filter by accounts: list of account names to filter by Returns: list of Note objects \"\"\" # TODO: should this be a generator? account_list = self . app . accounts () if accounts : format_str = \"name == %@\" + \" OR name == %@ \" * ( len ( accounts ) - 1 ) predicate = AppKit . NSPredicate . predicateWithFormat_ ( format_str , accounts ) account_list = account_list . filteredArrayUsingPredicate_ ( predicate ) notes = [] for account in account_list : notes . extend ( Account ( account ) . notes ( name , body , text , password_protected , id ) ) return notes noteslist ( name = None , body = None , text = None , password_protected = None , id = None , accounts = None ) Return NoteList object for all notes contained in account or notes filtered by property. Parameters: Name Type Description Default name list [ str ] | None list of note names to filter by None body list [ str ] | None list of note bodies to filter by None text list [ str ] | None list of note text to filter by None password_protected bool | None filter by password protected notes None id list [ str ] | None list of note ids to filter by None accounts list [ str ] | None list of account names to filter by None Returns: Type Description 'NotesList' NotesList object Source code in macnotesapp/notesapp.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def noteslist ( self , name : list [ str ] | None = None , body : list [ str ] | None = None , text : list [ str ] | None = None , password_protected : bool | None = None , id : list [ str ] | None = None , accounts : list [ str ] | None = None , ) -> \"NotesList\" : \"\"\"Return NoteList object for all notes contained in account or notes filtered by property. Args: name: list of note names to filter by body: list of note bodies to filter by text: list of note text to filter by password_protected: filter by password protected notes id: list of note ids to filter by accounts: list of account names to filter by Returns: NotesList object \"\"\" account_list = self . app . accounts () if accounts : format_str = \"name == %@\" + \" OR name == %@ \" * ( len ( accounts ) - 1 ) predicate = AppKit . NSPredicate . predicateWithFormat_ ( format_str , accounts ) account_list = account_list . filteredArrayUsingPredicate_ ( predicate ) noteslists = [ Account ( account ) . _noteslist ( name = name , body = body , text = text , password_protected = password_protected , id = id , ) for account in account_list ] return NotesList ( * noteslists ) quit () Quit Notes.app Source code in macnotesapp/notesapp.py 204 205 206 def quit ( self ) -> None : \"\"\"Quit Notes.app\"\"\" run_script ( \"notesQuit\" ) Account Notes.app Account object Source code in macnotesapp/notesapp.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 class Account : \"\"\"Notes.app Account object\"\"\" def __init__ ( self , account : ScriptingBridge . SBObject ): \"\"\"Initialize Account object\"\"\" self . _account = account @property def name ( self ) -> str : \"\"\"Return name of account\"\"\" return str ( self . _account . name ()) # return str(self._run_script(\"accountName\")) @property def folders ( self ) -> list [ str ]: \"\"\"Return list of folder names in account\"\"\" if folders := self . _account . folders (): return [ str ( f . name ()) for f in folders ] return [ str ( f ) for f in self . _run_script ( \"accountGetFolderNames\" )] @property def default_folder ( self ) -> str : \"\"\"Return name of default folder for account\"\"\" if default_folder := self . _account . defaultFolder (): return str ( default_folder . name ()) return str ( self . _run_script ( \"accountGetDefaultFolder\" )) @cached_property def id ( self ) -> str : \"\"\"Return ID of account\"\"\" if id_ := self . _account . id (): return str ( id_ ) return str ( self . _run_script ( \"accountID\" )) def notes ( self , name : list [ str ] | None = None , body : list [ str ] | None = None , text : list [ str ] | None = None , password_protected : bool | None = None , id : list [ str ] | None = None , ) -> list [ \"Note\" ]: \"\"\"Return Note object for all notes contained in account or notes filtered by property. Args: name: list of note names to filter by body: list of note bodies to filter by text: list of note text to filter by password_protected: filter by password protected notes id: list of note ids to filter by Returns: list of Note objects \"\"\" # TODO: should this be a generator? notes = self . _account . notes () format_strings = [] if name and notes : name_strings = [ \"(name contains[cd] %@)\" ] * len ( name ) format_strings . append ( name_strings ) if body and notes : body_strings = [ \"(plaintext contains[cd] %@)\" ] * len ( body ) format_strings . append ( body_strings ) if text and notes : text_strings = [ \"(name contains[cd] %@)\" ] * len ( text ) text_strings . extend ([ \"(plaintext contains[cd] %@)\" ] * len ( text )) format_strings . append ( text_strings ) if password_protected is not None and notes : password_string = ( [ \"(passwordProtected == TRUE)\" ] if password_protected else [ \"(passwordProtected == FALSE)\" ] ) format_strings . append ( password_string ) if id and notes : id_string = [ \"(id == %@)\" ] * len ( id ) format_strings . append ( id_string ) if format_strings : # have one or more search predicates; filter notes args = name or [] args += body or [] if text : args += text * 2 args += id or [] or_strings = [ \" OR \" . join ( strings ) for strings in format_strings ] format_str = \"(\" + \") AND (\" . join ( or_strings ) + \")\" predicate = AppKit . NSPredicate . predicateWithFormat_ ( format_str , * args ) notes = notes . filteredArrayUsingPredicate_ ( predicate ) return [ Note ( note ) for note in notes . get ()] def noteslist ( self , name : list [ str ] | None = None , body : list [ str ] | None = None , text : list [ str ] | None = None , password_protected : bool | None = None , id : list [ str ] | None = None , ) -> \"NotesList\" : \"\"\"Return NoteList object for all notes contained in account or notes filtered by property. Args: name: list of note names to filter by body: list of note bodies to filter by text: list of note text to filter by password_protected: filter by password protected notes id: list of note ids to filter by Returns: NotesList object\"\"\" notes = self . _noteslist ( name , body , text , password_protected , id ) return NotesList ( notes ) def folder ( self , folder : str ) -> \"Folder\" : \"\"\"Return Folder object for folder with name folder.\"\"\" folder_obj = self . _folder_for_name ( folder ) return Folder ( folder_obj ) def show ( self ): \"\"\"Show account in Notes.app UI\"\"\" self . _run_script ( \"accountShow\" ) def make_note ( self , name : str , body : str , folder : str | None = None , attachments : list [ str ] | None = None , ) -> \"Note\" : \"\"\"Create new note in account Args: name: name of note body: body of note folder: optional folder to create note in; if None, uses default folder attachments: optional list of file paths to attach to note Returns: Note object for new note Raises: ScriptingBridgeError: if note could not be created FileNotFoundError: if attachment file could not be found \"\"\" # reference: https://developer.apple.com/documentation/scriptingbridge/sbobject/1423973-initwithproperties notes_app = NotesApp () folder_obj = ( self . _folder_for_name ( folder ) if folder else self . _account . defaultFolder () ) properties = { \"body\" : f \"<div><h1> { name } </h1></div> \\n { body } \" , } note = ( notes_app . app . classForScriptingClass_ ( \"note\" ) . alloc () . initWithProperties_ ( properties ) ) notes = folder_obj . notes () len_before = len ( notes ) notes . addObject_ ( note ) len_after = len ( notes ) if len_after <= len_before : raise ScriptingBridgeError ( f \"Could not create note ' { name } ' with body ' { body } '\" ) new_note = Note ( note ) if attachments : for attachment in attachments : if not os . path . exists ( attachment ): raise FileNotFoundError ( f \"File { attachment } does not exist\" ) new_note . add_attachment ( attachment ) return new_note def _noteslist ( self , name : list [ str ] | None = None , body : list [ str ] | None = None , text : list [ str ] | None = None , password_protected : bool | None = None , id : list [ str ] | None = None , ) -> ScriptingBridge . SBElementArray : \"\"\"Return SBElementArray for all notes contained in account or notes filtered by property\"\"\" notes = self . _account . notes () format_strings = [] if name and notes : name_strings = [ \"(name contains[cd] %@)\" ] * len ( name ) format_strings . append ( name_strings ) if body and notes : body_strings = [ \"(plaintext contains[cd] %@)\" ] * len ( body ) format_strings . append ( body_strings ) if text and notes : text_strings = [ \"(name contains[cd] %@)\" ] * len ( text ) text_strings . extend ([ \"(plaintext contains[cd] %@)\" ] * len ( text )) format_strings . append ( text_strings ) if password_protected is not None and notes : password_string = ( [ \"(passwordProtected == TRUE)\" ] if password_protected else [ \"(passwordProtected == FALSE)\" ] ) format_strings . append ( password_string ) if id and notes : id_string = [ \"(id == %@)\" ] * len ( id ) format_strings . append ( id_string ) if format_strings : # have one or more search predicates; filter notes args = name or [] args += body or [] if text : args += text * 2 args += id or [] or_strings = [ \" OR \" . join ( strings ) for strings in format_strings ] format_str = \"(\" + \") AND (\" . join ( or_strings ) + \")\" predicate = AppKit . NSPredicate . predicateWithFormat_ ( format_str , * args ) notes = notes . filteredArrayUsingPredicate_ ( predicate ) return notes def _folder_for_name ( self , folder : str ) -> ScriptingBridge . SBObject : \"\"\"Return ScriptingBridge folder object for folder\"\"\" if folder_objs := self . _account . folders () . filteredArrayUsingPredicate_ ( AppKit . NSPredicate . predicateWithFormat_ ( \"name == %@\" , folder ) ): return folder_objs [ 0 ] else : raise ValueError ( f \"Could not find folder { folder } \" ) def _run_script ( self , script , * args ): return run_script ( script , self . name , * args ) def __len__ ( self ) -> int : \"\"\"Return count of notes\"\"\" return len ( self . _account . notes ()) # return self._run_script(\"accountGetCount\") def __iter__ ( self ) -> Generator [ Note , None , None ]: \"\"\"Generator to yield all notes contained in Notes.app\"\"\" for note in self . _account . notes (): yield Note ( note ) default_folder : str property Return name of default folder for account folders : list [ str ] property Return list of folder names in account id : str property cached Return ID of account name : str property Return name of account __init__ ( account ) Initialize Account object Source code in macnotesapp/notesapp.py 223 224 225 def __init__ ( self , account : ScriptingBridge . SBObject ): \"\"\"Initialize Account object\"\"\" self . _account = account __iter__ () Generator to yield all notes contained in Notes.app Source code in macnotesapp/notesapp.py 456 457 458 459 def __iter__ ( self ) -> Generator [ Note , None , None ]: \"\"\"Generator to yield all notes contained in Notes.app\"\"\" for note in self . _account . notes (): yield Note ( note ) __len__ () Return count of notes Source code in macnotesapp/notesapp.py 451 452 453 def __len__ ( self ) -> int : \"\"\"Return count of notes\"\"\" return len ( self . _account . notes ()) folder ( folder ) Return Folder object for folder with name folder. Source code in macnotesapp/notesapp.py 332 333 334 335 def folder ( self , folder : str ) -> \"Folder\" : \"\"\"Return Folder object for folder with name folder.\"\"\" folder_obj = self . _folder_for_name ( folder ) return Folder ( folder_obj ) make_note ( name , body , folder = None , attachments = None ) Create new note in account Parameters: Name Type Description Default name str name of note required body str body of note required folder str | None optional folder to create note in; if None, uses default folder None attachments list [ str ] | None optional list of file paths to attach to note None Returns: Type Description 'Note' Note object for new note Raises: Type Description ScriptingBridgeError if note could not be created FileNotFoundError if attachment file could not be found Source code in macnotesapp/notesapp.py 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 def make_note ( self , name : str , body : str , folder : str | None = None , attachments : list [ str ] | None = None , ) -> \"Note\" : \"\"\"Create new note in account Args: name: name of note body: body of note folder: optional folder to create note in; if None, uses default folder attachments: optional list of file paths to attach to note Returns: Note object for new note Raises: ScriptingBridgeError: if note could not be created FileNotFoundError: if attachment file could not be found \"\"\" # reference: https://developer.apple.com/documentation/scriptingbridge/sbobject/1423973-initwithproperties notes_app = NotesApp () folder_obj = ( self . _folder_for_name ( folder ) if folder else self . _account . defaultFolder () ) properties = { \"body\" : f \"<div><h1> { name } </h1></div> \\n { body } \" , } note = ( notes_app . app . classForScriptingClass_ ( \"note\" ) . alloc () . initWithProperties_ ( properties ) ) notes = folder_obj . notes () len_before = len ( notes ) notes . addObject_ ( note ) len_after = len ( notes ) if len_after <= len_before : raise ScriptingBridgeError ( f \"Could not create note ' { name } ' with body ' { body } '\" ) new_note = Note ( note ) if attachments : for attachment in attachments : if not os . path . exists ( attachment ): raise FileNotFoundError ( f \"File { attachment } does not exist\" ) new_note . add_attachment ( attachment ) return new_note notes ( name = None , body = None , text = None , password_protected = None , id = None ) Return Note object for all notes contained in account or notes filtered by property. Parameters: Name Type Description Default name list [ str ] | None list of note names to filter by None body list [ str ] | None list of note bodies to filter by None text list [ str ] | None list of note text to filter by None password_protected bool | None filter by password protected notes None id list [ str ] | None list of note ids to filter by None Returns: Type Description list ['Note'] list of Note objects Source code in macnotesapp/notesapp.py 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def notes ( self , name : list [ str ] | None = None , body : list [ str ] | None = None , text : list [ str ] | None = None , password_protected : bool | None = None , id : list [ str ] | None = None , ) -> list [ \"Note\" ]: \"\"\"Return Note object for all notes contained in account or notes filtered by property. Args: name: list of note names to filter by body: list of note bodies to filter by text: list of note text to filter by password_protected: filter by password protected notes id: list of note ids to filter by Returns: list of Note objects \"\"\" # TODO: should this be a generator? notes = self . _account . notes () format_strings = [] if name and notes : name_strings = [ \"(name contains[cd] %@)\" ] * len ( name ) format_strings . append ( name_strings ) if body and notes : body_strings = [ \"(plaintext contains[cd] %@)\" ] * len ( body ) format_strings . append ( body_strings ) if text and notes : text_strings = [ \"(name contains[cd] %@)\" ] * len ( text ) text_strings . extend ([ \"(plaintext contains[cd] %@)\" ] * len ( text )) format_strings . append ( text_strings ) if password_protected is not None and notes : password_string = ( [ \"(passwordProtected == TRUE)\" ] if password_protected else [ \"(passwordProtected == FALSE)\" ] ) format_strings . append ( password_string ) if id and notes : id_string = [ \"(id == %@)\" ] * len ( id ) format_strings . append ( id_string ) if format_strings : # have one or more search predicates; filter notes args = name or [] args += body or [] if text : args += text * 2 args += id or [] or_strings = [ \" OR \" . join ( strings ) for strings in format_strings ] format_str = \"(\" + \") AND (\" . join ( or_strings ) + \")\" predicate = AppKit . NSPredicate . predicateWithFormat_ ( format_str , * args ) notes = notes . filteredArrayUsingPredicate_ ( predicate ) return [ Note ( note ) for note in notes . get ()] noteslist ( name = None , body = None , text = None , password_protected = None , id = None ) Return NoteList object for all notes contained in account or notes filtered by property. Parameters: Name Type Description Default name list [ str ] | None list of note names to filter by None body list [ str ] | None list of note bodies to filter by None text list [ str ] | None list of note text to filter by None password_protected bool | None filter by password protected notes None id list [ str ] | None list of note ids to filter by None Returns: Type Description 'NotesList' NotesList object Source code in macnotesapp/notesapp.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 def noteslist ( self , name : list [ str ] | None = None , body : list [ str ] | None = None , text : list [ str ] | None = None , password_protected : bool | None = None , id : list [ str ] | None = None , ) -> \"NotesList\" : \"\"\"Return NoteList object for all notes contained in account or notes filtered by property. Args: name: list of note names to filter by body: list of note bodies to filter by text: list of note text to filter by password_protected: filter by password protected notes id: list of note ids to filter by Returns: NotesList object\"\"\" notes = self . _noteslist ( name , body , text , password_protected , id ) return NotesList ( notes ) show () Show account in Notes.app UI Source code in macnotesapp/notesapp.py 337 338 339 def show ( self ): \"\"\"Show account in Notes.app UI\"\"\" self . _run_script ( \"accountShow\" ) Folder Folder object Source code in macnotesapp/notesapp.py 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 class Folder : \"\"\"Folder object\"\"\" def __init__ ( self , folder : ScriptingBridge . SBObject ): self . _folder = folder @cached_property def id ( self ) -> str : \"\"\"ID of folder\"\"\" return ( str ( folder_id ) if ( folder_id := self . _folder . id ()) else str ( parse_id_from_object ( self . _folder . get ())) ) @property def name ( self ) -> str : \"\"\"Name of folder\"\"\" return str ( self . _folder . name ()) id : str property cached ID of folder name : str property Name of folder Note Note object representing a note in Notes.app Source code in macnotesapp/notesapp.py 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 class Note : \"\"\"Note object representing a note in Notes.app\"\"\" def __init__ ( self , note : ScriptingBridge . SBObject ): self . _note = note @property def account ( self ) -> str : \"\"\"Return name of account note belongs to.\"\"\" # can't determine this easily from the note object # so may to use AppleScript return str ( run_script ( \"noteGetAccount\" , self . id )) @cached_property def id ( self ) -> str : \"\"\"Return note ID\"\"\" if note_id := self . _note . id (): return str ( note_id ) else : # if note object created from selection or predicate it may show ID of 0 # but the ID is in the string representation of the object so parse it return parse_id_from_object ( self . _note ) or 0 @property def name ( self ) -> str : \"\"\"Return name of note\"\"\" return ( str ( name ) if ( name := self . _note . name ()) else self . _run_script ( \"noteGetName\" ) ) @name . setter def name ( self , name : str ): \"\"\"Set name of note\"\"\" self . _note . setValue_forKey_ ( name , \"name\" ) if self . name != name : self . _run_script ( \"noteSetName\" , name ) @property def body ( self ) -> str : \"\"\"Return body of note\"\"\" return ( str ( body ) if ( body := self . _note . body ()) else str ( self . _run_script ( \"noteGetBody\" )) ) @body . setter def body ( self , body : str ): \"\"\"Set body of note\"\"\" self . _note . setValue_forKey_ ( body , \"body\" ) if self . body != body : self . _run_script ( \"noteSetBody\" , body ) @property def plaintext ( self ) -> str : \"\"\"Return plaintext of note\"\"\" return ( str ( plaintext ) if ( plaintext := self . _note . plaintext ()) else str ( self . _run_script ( \"noteGetPlainText\" )) ) @property def creation_date ( self ) -> datetime : \"\"\"Return creation date of note as datetime\"\"\" if date := self . _note . creationDate (): return NSDate_to_datetime ( date ) else : return self . _run_script ( \"noteGetCreationDate\" ) @property def modification_date ( self ) -> datetime : \"\"\"Return modification date of note as datetime\"\"\" if date := self . _note . modificationDate (): return NSDate_to_datetime ( date ) else : return self . _run_script ( \"noteGetModificationDate\" ) @property def password_protected ( self ) -> bool : \"\"\"Return password protected status of note\"\"\" # return self._note.passwordProtected() # returns False even when note is password protected on some OS versions if MAC_OS_VERSION >= 13 : return bool ( self . _note . passwordProtected ()) return bool ( self . _run_script ( \"noteGetPasswordProtected\" )) @property def folder ( self ) -> str : \"\"\"Return name of folder note is contained in\"\"\" # calling container() method on note object returns None # in many cases, so use AppleScript instead return self . _note . container () . name () or self . _run_script ( \"noteGetContainer\" ) @property def attachments ( self ) -> list [ \"Attachment\" ]: \"\"\"Return list of attachments for note as Attachment objects\"\"\" # .attachments() method on note object sometimes returns duplicates, e.g each attachment is returned twice # filter out duplicates by comparing attachment ID # this appears to happen only with attachments added via AppleScript or ScriptingBridge # not with those natively added in Notes.app attachments = [ Attachment ( attachment ) for attachment in self . _note . attachments () ] return [ attachment for i , attachment in enumerate ( attachments ) if attachment . id not in [ a . id for a in attachments [: i ]] ] def add_attachment ( self , path : str ) -> \"Attachment\" : \"\"\"Add attachment to note Args: path: path to file to attach Returns: Attachment object for attached file Raises: FileNotFoundError: if file not found \"\"\" # Implementation note: # this is currently done with AppleScript which takes ~300ms on M1 Mac # it's faster with ScriptingBridge (~80ms) but when adding via ScriptingBridge # the attachment sometimes is added twice # See #15 for more details # must pass fully resolved path to AppleScript path = pathlib . Path ( path ) . expanduser () . resolve () if not path . exists (): raise FileNotFoundError ( f \"File not found: { path } \" ) attachment_id = self . _run_script ( \"noteAddAttachment\" , str ( path )) return Attachment ( self . _note . attachments () . objectWithID_ ( attachment_id )) def show ( self ): \"\"\"Show note in Notes.app UI\"\"\" self . _run_script ( \"noteShow\" ) def asdict ( self ) -> dict [ str , Any ]: \"\"\"Return dict representation of note\"\"\" return { \"account\" : self . account , \"id\" : self . id , \"name\" : self . name , \"body\" : self . body , \"plaintext\" : self . plaintext , \"creation_date\" : self . creation_date , \"modification_date\" : self . modification_date , \"password_protected\" : self . password_protected , \"folder\" : self . folder , } def _run_script ( self , script : str , * args ): \"\"\"Run AppleScript script\"\"\" return run_script ( script , self . account , self . id , * args ) def _parse_id_from_object ( self ) -> str : \"\"\"Parse the ID from the object representation when it can't be determined by ScriptingBridge\"\"\" # there are some conditions (e.g. using selection on Catalina or using a predicate) # where the ScriptingBridge sets the object ID to 0 # I haven't been able to figure out why but in this case, the id can be determined # by examining the string representation of the object which looks like this: # <SBObject @0x7fd721544690: <class ''> id \"x-coredata://19B82A76-B3FE-4427-9C5E-5107C1E3CA57/IMAPNote/p87\" of application \"Notes\" (55036)> if match := re . search ( r 'id \"(x-coredata://.+?)\"' , str ( self . _note )): return match [ 1 ] return None def __repr__ ( self ) -> str : return f \"Note( { self . id } )\" def __eq__ ( self , other : \"Note\" ): return ( self . id , self . account ) == ( other . id , other . account ) def __hash__ ( self ) -> int : return hash ( repr ( self )) account : str property Return name of account note belongs to. attachments : list [ 'Attachment' ] property Return list of attachments for note as Attachment objects body : str property writable Return body of note creation_date : datetime property Return creation date of note as datetime folder : str property Return name of folder note is contained in id : str property cached Return note ID modification_date : datetime property Return modification date of note as datetime name : str property writable Return name of note password_protected : bool property Return password protected status of note plaintext : str property Return plaintext of note add_attachment ( path ) Add attachment to note Parameters: Name Type Description Default path str path to file to attach required Returns: Type Description 'Attachment' Attachment object for attached file Raises: Type Description FileNotFoundError if file not found Source code in macnotesapp/notesapp.py 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 def add_attachment ( self , path : str ) -> \"Attachment\" : \"\"\"Add attachment to note Args: path: path to file to attach Returns: Attachment object for attached file Raises: FileNotFoundError: if file not found \"\"\" # Implementation note: # this is currently done with AppleScript which takes ~300ms on M1 Mac # it's faster with ScriptingBridge (~80ms) but when adding via ScriptingBridge # the attachment sometimes is added twice # See #15 for more details # must pass fully resolved path to AppleScript path = pathlib . Path ( path ) . expanduser () . resolve () if not path . exists (): raise FileNotFoundError ( f \"File not found: { path } \" ) attachment_id = self . _run_script ( \"noteAddAttachment\" , str ( path )) return Attachment ( self . _note . attachments () . objectWithID_ ( attachment_id )) asdict () Return dict representation of note Source code in macnotesapp/notesapp.py 700 701 702 703 704 705 706 707 708 709 710 711 712 def asdict ( self ) -> dict [ str , Any ]: \"\"\"Return dict representation of note\"\"\" return { \"account\" : self . account , \"id\" : self . id , \"name\" : self . name , \"body\" : self . body , \"plaintext\" : self . plaintext , \"creation_date\" : self . creation_date , \"modification_date\" : self . modification_date , \"password_protected\" : self . password_protected , \"folder\" : self . folder , } show () Show note in Notes.app UI Source code in macnotesapp/notesapp.py 696 697 698 def show ( self ): \"\"\"Show note in Notes.app UI\"\"\" self . _run_script ( \"noteShow\" ) NotesList NotesList object for list of notes. Represents an SBElementArray of notes as returned by noteslist() Source code in macnotesapp/notesapp.py 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 class NotesList : \"\"\"NotesList object for list of notes. Represents an SBElementArray of notes as returned by noteslist() \"\"\" def __init__ ( self , * noteslist : ScriptingBridge . SBElementArray ): self . _noteslist = noteslist @property def id ( self ) -> list [ str ]: \"\"\"Return ID of every note in list as list of strings\"\"\" return self . _apply_selector ( \"id\" ) @property def name ( self ) -> list [ str ]: \"\"\"Return name of every note in list as list of strings\"\"\" return self . _apply_selector ( \"name\" ) @property def body ( self ) -> list [ str ]: \"\"\"Return body of every note in list as list of strings\"\"\" return self . _apply_selector ( \"body\" ) @property def plaintext ( self ) -> list [ str ]: \"\"\"Return plaintext of every note in list as list of strings\"\"\" return self . _apply_selector ( \"plaintext\" ) @property def container ( self ) -> list [ str ]: \"\"\"Return container of every note in list as list of strings\"\"\" return self . _apply_selector ( \"container\" ) @property def folder ( self ) -> list [ str ]: \"\"\"Return folder of every note in list as list of strings\"\"\" return self . container @property def creation_date ( self ) -> list [ datetime ]: \"\"\"Return creation date of every note in list as list of datetimes\"\"\" return self . _apply_selector ( \"creationDate\" ) @property def modification_date ( self ) -> list [ datetime ]: \"\"\"Return modification date of every note in list as list of datetimes\"\"\" return self . _apply_selector ( \"modificationDate\" ) @property def password_protected ( self ) -> list [ bool ]: \"\"\"Return whether every note in list is password protected as list of bools\"\"\" return self . _apply_selector ( \"passwordProtected\" ) def asdict ( self ) -> list [ dict [ str , str ]]: \"\"\"Return list of dict representations of note\"\"\" return [ { \"id\" : note [ 0 ], \"name\" : note [ 1 ], \"body\" : note [ 2 ], \"plaintext\" : note [ 3 ], \"creation_date\" : note [ 4 ], \"modification_date\" : note [ 5 ], \"password_protected\" : note [ 6 ], \"folder\" : note [ 7 ], } for note in zip ( self . id , self . name , self . body , self . plaintext , self . creation_date , self . modification_date , self . password_protected , self . container , ) ] def _apply_selector ( self , selector ) -> list [ str ]: \"\"\"Return note properties in list that pass selector\"\"\" results_list = [] for noteslist in self . _noteslist : results = noteslist . arrayByApplyingSelector_ ( selector ) if selector in [ \"creationDate\" , \"modificationDate\" ]: results_list . extend ( NSDate_to_datetime ( date ) for date in results ) elif selector == \"container\" : results_list . extend ( str ( container . name ()) for container in results ) else : results_list . extend ([ str ( r ) for r in results ]) return results_list def __len__ ( self ) -> int : \"\"\"Return count of notes in list\"\"\" return len ( self . id ) body : list [ str ] property Return body of every note in list as list of strings container : list [ str ] property Return container of every note in list as list of strings creation_date : list [ datetime ] property Return creation date of every note in list as list of datetimes folder : list [ str ] property Return folder of every note in list as list of strings id : list [ str ] property Return ID of every note in list as list of strings modification_date : list [ datetime ] property Return modification date of every note in list as list of datetimes name : list [ str ] property Return name of every note in list as list of strings password_protected : list [ bool ] property Return whether every note in list is password protected as list of bools plaintext : list [ str ] property Return plaintext of every note in list as list of strings __len__ () Return count of notes in list Source code in macnotesapp/notesapp.py 553 554 555 def __len__ ( self ) -> int : \"\"\"Return count of notes in list\"\"\" return len ( self . id ) asdict () Return list of dict representations of note Source code in macnotesapp/notesapp.py 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 def asdict ( self ) -> list [ dict [ str , str ]]: \"\"\"Return list of dict representations of note\"\"\" return [ { \"id\" : note [ 0 ], \"name\" : note [ 1 ], \"body\" : note [ 2 ], \"plaintext\" : note [ 3 ], \"creation_date\" : note [ 4 ], \"modification_date\" : note [ 5 ], \"password_protected\" : note [ 6 ], \"folder\" : note [ 7 ], } for note in zip ( self . id , self . name , self . body , self . plaintext , self . creation_date , self . modification_date , self . password_protected , self . container , ) ] Attachment Notes.app Attachment object Source code in macnotesapp/notesapp.py 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 class Attachment : \"\"\"Notes.app Attachment object\"\"\" def __init__ ( self , attachment : ScriptingBridge . SBObject ): self . _attachment = attachment @cached_property def id ( self ) -> str : \"\"\"ID of attachment\"\"\" return str ( self . _attachment . id ()) @property def name ( self ) -> str : \"\"\"Name of attachment\"\"\" return str ( name ) if ( name := self . _attachment . name ()) else None @property def creation_date ( self ) -> datetime : \"\"\"Creation date of attachment\"\"\" return NSDate_to_datetime ( self . _attachment . creationDate ()) @property def modification_date ( self ) -> datetime : \"\"\"Modification date of attachment\"\"\" return NSDate_to_datetime ( self . _attachment . modificationDate ()) @property def content_identifier ( self ) -> str : \"\"\"The content-id URL in the note's HTML\"\"\" return str ( ci ) if ( ci := self . _attachment . contentIdentifier ()) else None @property def URL ( self ) -> str : \"\"\"For URL attachments, the URL the attachment represents\"\"\" return str ( url ) if ( url := self . _attachment . URL ()) else None def save ( self , path : str | bytes | os . PathLike ) -> str : \"\"\"Save attachment to file\"\"\" if not os . path . exists ( str ( path )): raise FileNotFoundError ( f \"Path does not exist: { path } \" ) url = AppKit . NSURL . alloc () . initFileURLWithPath_ ( os . path . join ( str ( path ), self . name ) ) self . _attachment . saveIn_as_ ( url , OSType ( \"item\" )) return str ( url . path ()) URL : str property For URL attachments, the URL the attachment represents content_identifier : str property The content-id URL in the note's HTML creation_date : datetime property Creation date of attachment id : str property cached ID of attachment modification_date : datetime property Modification date of attachment name : str property Name of attachment save ( path ) Save attachment to file Source code in macnotesapp/notesapp.py 776 777 778 779 780 781 782 783 784 785 def save ( self , path : str | bytes | os . PathLike ) -> str : \"\"\"Save attachment to file\"\"\" if not os . path . exists ( str ( path )): raise FileNotFoundError ( f \"Path does not exist: { path } \" ) url = AppKit . NSURL . alloc () . initFileURLWithPath_ ( os . path . join ( str ( path ), self . name ) ) self . _attachment . saveIn_as_ ( url , OSType ( \"item\" )) return str ( url . path ())","title":"API Reference"},{"location":"reference/#reference","text":"","title":"Reference"},{"location":"reference/#notesapp","text":"Represents Notes.app instance Source code in macnotesapp/notesapp.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 class NotesApp : \"\"\"Represents Notes.app instance\"\"\" def __init__ ( self ): \"\"\"create new NotesApp object\"\"\" self . _app = ScriptingBridge . SBApplication . applicationWithBundleIdentifier_ ( \"com.apple.Notes\" ) @property def app ( self ): \"\"\"Return Notes.app SBApplication object\"\"\" return self . _app @property def accounts ( self ) -> list [ str ]: \"\"\"Return list of accounts\"\"\" return [ str ( a . name ()) for a in self . _app . accounts ()] @property def default_account ( self ) -> str : \"\"\"Return name of default account\"\"\" return str ( self . _app . defaultAccount () . name ()) def notes ( self , name : list [ str ] | None = None , body : list [ str ] | None = None , text : list [ str ] | None = None , password_protected : bool | None = None , id : list [ str ] | None = None , accounts : list [ str ] | None = None , ) -> list [ \"Note\" ]: \"\"\"Return Note object for all notes contained in Notes.app or notes filtered by property. Args: name: list of note names to filter by body: list of note bodies to filter by text: list of note text to filter by password_protected: filter by password protected notes id: list of note ids to filter by accounts: list of account names to filter by Returns: list of Note objects \"\"\" # TODO: should this be a generator? account_list = self . app . accounts () if accounts : format_str = \"name == %@\" + \" OR name == %@ \" * ( len ( accounts ) - 1 ) predicate = AppKit . NSPredicate . predicateWithFormat_ ( format_str , accounts ) account_list = account_list . filteredArrayUsingPredicate_ ( predicate ) notes = [] for account in account_list : notes . extend ( Account ( account ) . notes ( name , body , text , password_protected , id ) ) return notes def noteslist ( self , name : list [ str ] | None = None , body : list [ str ] | None = None , text : list [ str ] | None = None , password_protected : bool | None = None , id : list [ str ] | None = None , accounts : list [ str ] | None = None , ) -> \"NotesList\" : \"\"\"Return NoteList object for all notes contained in account or notes filtered by property. Args: name: list of note names to filter by body: list of note bodies to filter by text: list of note text to filter by password_protected: filter by password protected notes id: list of note ids to filter by accounts: list of account names to filter by Returns: NotesList object \"\"\" account_list = self . app . accounts () if accounts : format_str = \"name == %@\" + \" OR name == %@ \" * ( len ( accounts ) - 1 ) predicate = AppKit . NSPredicate . predicateWithFormat_ ( format_str , accounts ) account_list = account_list . filteredArrayUsingPredicate_ ( predicate ) noteslists = [ Account ( account ) . _noteslist ( name = name , body = body , text = text , password_protected = password_protected , id = id , ) for account in account_list ] return NotesList ( * noteslists ) @property def selection ( self ) -> list [ \"Note\" ]: \"\"\"Return lit of Note objects for selected notes\"\"\" notes = self . app . selection () return [ Note ( note ) for note in notes ] @property def version ( self ) -> str : \"\"\"Return version of Notes.app\"\"\" return str ( self . app . version ()) def make_note ( self , name : str , body : str , attachments : list [ str ] | None = None ) -> \"Note\" : \"\"\"Create new note in default folder of default account. Args: name: name of notes body: body of note as HTML text attachments: optional list of paths to attachments to add to note Returns: newly created Note object \"\"\" # reference: https://developer.apple.com/documentation/scriptingbridge/sbobject/1423973-initwithproperties account = Account ( self . app . defaultAccount ()) note = account . make_note ( name , body ) if attachments : for attachment in attachments : note . add_attachment ( attachment ) return note def account ( self , account : Optional [ str ] = None ) -> \"Account\" : \"\"\"Return Account object for account or default account if account is None. Arg: account: name of account to return. If None, return default account. Returns: Account object \"\"\" account = account or self . default_account predicate = AppKit . NSPredicate . predicateWithFormat_ ( \"name == %@\" , account ) accounts = self . app . accounts () . filteredArrayUsingPredicate_ ( predicate ) if not accounts : raise ValueError ( f \"Could not find account { account } \" ) account_obj = accounts [ 0 ] return Account ( account_obj ) def activate ( self ) -> None : \"\"\"Activate Notes.app\"\"\" run_script ( \"notesActivate\" ) def quit ( self ) -> None : \"\"\"Quit Notes.app\"\"\" run_script ( \"notesQuit\" ) def __len__ ( self ) -> int : \"\"\"Return count of notes in Notes.app\"\"\" return sum ( len ( account . notes ()) for account in self . app . accounts ()) def __iter__ ( self ) -> Generator [ \"Note\" , None , None ]: \"\"\"Generator to yield Note object for all notes contained in Notes.app\"\"\" for account in self . app . accounts (): notes = account . notes () for note in notes : yield Note ( note )","title":"NotesApp"},{"location":"reference/#macnotesapp.notesapp.NotesApp.accounts","text":"Return list of accounts","title":"accounts"},{"location":"reference/#macnotesapp.notesapp.NotesApp.app","text":"Return Notes.app SBApplication object","title":"app"},{"location":"reference/#macnotesapp.notesapp.NotesApp.default_account","text":"Return name of default account","title":"default_account"},{"location":"reference/#macnotesapp.notesapp.NotesApp.selection","text":"Return lit of Note objects for selected notes","title":"selection"},{"location":"reference/#macnotesapp.notesapp.NotesApp.version","text":"Return version of Notes.app","title":"version"},{"location":"reference/#macnotesapp.notesapp.NotesApp.__init__","text":"create new NotesApp object Source code in macnotesapp/notesapp.py 56 57 58 59 60 def __init__ ( self ): \"\"\"create new NotesApp object\"\"\" self . _app = ScriptingBridge . SBApplication . applicationWithBundleIdentifier_ ( \"com.apple.Notes\" )","title":"__init__()"},{"location":"reference/#macnotesapp.notesapp.NotesApp.__iter__","text":"Generator to yield Note object for all notes contained in Notes.app Source code in macnotesapp/notesapp.py 212 213 214 215 216 217 def __iter__ ( self ) -> Generator [ \"Note\" , None , None ]: \"\"\"Generator to yield Note object for all notes contained in Notes.app\"\"\" for account in self . app . accounts (): notes = account . notes () for note in notes : yield Note ( note )","title":"__iter__()"},{"location":"reference/#macnotesapp.notesapp.NotesApp.__len__","text":"Return count of notes in Notes.app Source code in macnotesapp/notesapp.py 208 209 210 def __len__ ( self ) -> int : \"\"\"Return count of notes in Notes.app\"\"\" return sum ( len ( account . notes ()) for account in self . app . accounts ())","title":"__len__()"},{"location":"reference/#macnotesapp.notesapp.NotesApp.account","text":"Return Account object for account or default account if account is None. Arg account: name of account to return. If None, return default account. Returns: Type Description 'Account' Account object Source code in macnotesapp/notesapp.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def account ( self , account : Optional [ str ] = None ) -> \"Account\" : \"\"\"Return Account object for account or default account if account is None. Arg: account: name of account to return. If None, return default account. Returns: Account object \"\"\" account = account or self . default_account predicate = AppKit . NSPredicate . predicateWithFormat_ ( \"name == %@\" , account ) accounts = self . app . accounts () . filteredArrayUsingPredicate_ ( predicate ) if not accounts : raise ValueError ( f \"Could not find account { account } \" ) account_obj = accounts [ 0 ] return Account ( account_obj )","title":"account()"},{"location":"reference/#macnotesapp.notesapp.NotesApp.activate","text":"Activate Notes.app Source code in macnotesapp/notesapp.py 200 201 202 def activate ( self ) -> None : \"\"\"Activate Notes.app\"\"\" run_script ( \"notesActivate\" )","title":"activate()"},{"location":"reference/#macnotesapp.notesapp.NotesApp.make_note","text":"Create new note in default folder of default account. Parameters: Name Type Description Default name str name of notes required body str body of note as HTML text required attachments list [ str ] | None optional list of paths to attachments to add to note None Returns: Type Description 'Note' newly created Note object Source code in macnotesapp/notesapp.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def make_note ( self , name : str , body : str , attachments : list [ str ] | None = None ) -> \"Note\" : \"\"\"Create new note in default folder of default account. Args: name: name of notes body: body of note as HTML text attachments: optional list of paths to attachments to add to note Returns: newly created Note object \"\"\" # reference: https://developer.apple.com/documentation/scriptingbridge/sbobject/1423973-initwithproperties account = Account ( self . app . defaultAccount ()) note = account . make_note ( name , body ) if attachments : for attachment in attachments : note . add_attachment ( attachment ) return note","title":"make_note()"},{"location":"reference/#macnotesapp.notesapp.NotesApp.notes","text":"Return Note object for all notes contained in Notes.app or notes filtered by property. Parameters: Name Type Description Default name list [ str ] | None list of note names to filter by None body list [ str ] | None list of note bodies to filter by None text list [ str ] | None list of note text to filter by None password_protected bool | None filter by password protected notes None id list [ str ] | None list of note ids to filter by None accounts list [ str ] | None list of account names to filter by None Returns: Type Description list ['Note'] list of Note objects Source code in macnotesapp/notesapp.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def notes ( self , name : list [ str ] | None = None , body : list [ str ] | None = None , text : list [ str ] | None = None , password_protected : bool | None = None , id : list [ str ] | None = None , accounts : list [ str ] | None = None , ) -> list [ \"Note\" ]: \"\"\"Return Note object for all notes contained in Notes.app or notes filtered by property. Args: name: list of note names to filter by body: list of note bodies to filter by text: list of note text to filter by password_protected: filter by password protected notes id: list of note ids to filter by accounts: list of account names to filter by Returns: list of Note objects \"\"\" # TODO: should this be a generator? account_list = self . app . accounts () if accounts : format_str = \"name == %@\" + \" OR name == %@ \" * ( len ( accounts ) - 1 ) predicate = AppKit . NSPredicate . predicateWithFormat_ ( format_str , accounts ) account_list = account_list . filteredArrayUsingPredicate_ ( predicate ) notes = [] for account in account_list : notes . extend ( Account ( account ) . notes ( name , body , text , password_protected , id ) ) return notes","title":"notes()"},{"location":"reference/#macnotesapp.notesapp.NotesApp.noteslist","text":"Return NoteList object for all notes contained in account or notes filtered by property. Parameters: Name Type Description Default name list [ str ] | None list of note names to filter by None body list [ str ] | None list of note bodies to filter by None text list [ str ] | None list of note text to filter by None password_protected bool | None filter by password protected notes None id list [ str ] | None list of note ids to filter by None accounts list [ str ] | None list of account names to filter by None Returns: Type Description 'NotesList' NotesList object Source code in macnotesapp/notesapp.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def noteslist ( self , name : list [ str ] | None = None , body : list [ str ] | None = None , text : list [ str ] | None = None , password_protected : bool | None = None , id : list [ str ] | None = None , accounts : list [ str ] | None = None , ) -> \"NotesList\" : \"\"\"Return NoteList object for all notes contained in account or notes filtered by property. Args: name: list of note names to filter by body: list of note bodies to filter by text: list of note text to filter by password_protected: filter by password protected notes id: list of note ids to filter by accounts: list of account names to filter by Returns: NotesList object \"\"\" account_list = self . app . accounts () if accounts : format_str = \"name == %@\" + \" OR name == %@ \" * ( len ( accounts ) - 1 ) predicate = AppKit . NSPredicate . predicateWithFormat_ ( format_str , accounts ) account_list = account_list . filteredArrayUsingPredicate_ ( predicate ) noteslists = [ Account ( account ) . _noteslist ( name = name , body = body , text = text , password_protected = password_protected , id = id , ) for account in account_list ] return NotesList ( * noteslists )","title":"noteslist()"},{"location":"reference/#macnotesapp.notesapp.NotesApp.quit","text":"Quit Notes.app Source code in macnotesapp/notesapp.py 204 205 206 def quit ( self ) -> None : \"\"\"Quit Notes.app\"\"\" run_script ( \"notesQuit\" )","title":"quit()"},{"location":"reference/#account","text":"Notes.app Account object Source code in macnotesapp/notesapp.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 class Account : \"\"\"Notes.app Account object\"\"\" def __init__ ( self , account : ScriptingBridge . SBObject ): \"\"\"Initialize Account object\"\"\" self . _account = account @property def name ( self ) -> str : \"\"\"Return name of account\"\"\" return str ( self . _account . name ()) # return str(self._run_script(\"accountName\")) @property def folders ( self ) -> list [ str ]: \"\"\"Return list of folder names in account\"\"\" if folders := self . _account . folders (): return [ str ( f . name ()) for f in folders ] return [ str ( f ) for f in self . _run_script ( \"accountGetFolderNames\" )] @property def default_folder ( self ) -> str : \"\"\"Return name of default folder for account\"\"\" if default_folder := self . _account . defaultFolder (): return str ( default_folder . name ()) return str ( self . _run_script ( \"accountGetDefaultFolder\" )) @cached_property def id ( self ) -> str : \"\"\"Return ID of account\"\"\" if id_ := self . _account . id (): return str ( id_ ) return str ( self . _run_script ( \"accountID\" )) def notes ( self , name : list [ str ] | None = None , body : list [ str ] | None = None , text : list [ str ] | None = None , password_protected : bool | None = None , id : list [ str ] | None = None , ) -> list [ \"Note\" ]: \"\"\"Return Note object for all notes contained in account or notes filtered by property. Args: name: list of note names to filter by body: list of note bodies to filter by text: list of note text to filter by password_protected: filter by password protected notes id: list of note ids to filter by Returns: list of Note objects \"\"\" # TODO: should this be a generator? notes = self . _account . notes () format_strings = [] if name and notes : name_strings = [ \"(name contains[cd] %@)\" ] * len ( name ) format_strings . append ( name_strings ) if body and notes : body_strings = [ \"(plaintext contains[cd] %@)\" ] * len ( body ) format_strings . append ( body_strings ) if text and notes : text_strings = [ \"(name contains[cd] %@)\" ] * len ( text ) text_strings . extend ([ \"(plaintext contains[cd] %@)\" ] * len ( text )) format_strings . append ( text_strings ) if password_protected is not None and notes : password_string = ( [ \"(passwordProtected == TRUE)\" ] if password_protected else [ \"(passwordProtected == FALSE)\" ] ) format_strings . append ( password_string ) if id and notes : id_string = [ \"(id == %@)\" ] * len ( id ) format_strings . append ( id_string ) if format_strings : # have one or more search predicates; filter notes args = name or [] args += body or [] if text : args += text * 2 args += id or [] or_strings = [ \" OR \" . join ( strings ) for strings in format_strings ] format_str = \"(\" + \") AND (\" . join ( or_strings ) + \")\" predicate = AppKit . NSPredicate . predicateWithFormat_ ( format_str , * args ) notes = notes . filteredArrayUsingPredicate_ ( predicate ) return [ Note ( note ) for note in notes . get ()] def noteslist ( self , name : list [ str ] | None = None , body : list [ str ] | None = None , text : list [ str ] | None = None , password_protected : bool | None = None , id : list [ str ] | None = None , ) -> \"NotesList\" : \"\"\"Return NoteList object for all notes contained in account or notes filtered by property. Args: name: list of note names to filter by body: list of note bodies to filter by text: list of note text to filter by password_protected: filter by password protected notes id: list of note ids to filter by Returns: NotesList object\"\"\" notes = self . _noteslist ( name , body , text , password_protected , id ) return NotesList ( notes ) def folder ( self , folder : str ) -> \"Folder\" : \"\"\"Return Folder object for folder with name folder.\"\"\" folder_obj = self . _folder_for_name ( folder ) return Folder ( folder_obj ) def show ( self ): \"\"\"Show account in Notes.app UI\"\"\" self . _run_script ( \"accountShow\" ) def make_note ( self , name : str , body : str , folder : str | None = None , attachments : list [ str ] | None = None , ) -> \"Note\" : \"\"\"Create new note in account Args: name: name of note body: body of note folder: optional folder to create note in; if None, uses default folder attachments: optional list of file paths to attach to note Returns: Note object for new note Raises: ScriptingBridgeError: if note could not be created FileNotFoundError: if attachment file could not be found \"\"\" # reference: https://developer.apple.com/documentation/scriptingbridge/sbobject/1423973-initwithproperties notes_app = NotesApp () folder_obj = ( self . _folder_for_name ( folder ) if folder else self . _account . defaultFolder () ) properties = { \"body\" : f \"<div><h1> { name } </h1></div> \\n { body } \" , } note = ( notes_app . app . classForScriptingClass_ ( \"note\" ) . alloc () . initWithProperties_ ( properties ) ) notes = folder_obj . notes () len_before = len ( notes ) notes . addObject_ ( note ) len_after = len ( notes ) if len_after <= len_before : raise ScriptingBridgeError ( f \"Could not create note ' { name } ' with body ' { body } '\" ) new_note = Note ( note ) if attachments : for attachment in attachments : if not os . path . exists ( attachment ): raise FileNotFoundError ( f \"File { attachment } does not exist\" ) new_note . add_attachment ( attachment ) return new_note def _noteslist ( self , name : list [ str ] | None = None , body : list [ str ] | None = None , text : list [ str ] | None = None , password_protected : bool | None = None , id : list [ str ] | None = None , ) -> ScriptingBridge . SBElementArray : \"\"\"Return SBElementArray for all notes contained in account or notes filtered by property\"\"\" notes = self . _account . notes () format_strings = [] if name and notes : name_strings = [ \"(name contains[cd] %@)\" ] * len ( name ) format_strings . append ( name_strings ) if body and notes : body_strings = [ \"(plaintext contains[cd] %@)\" ] * len ( body ) format_strings . append ( body_strings ) if text and notes : text_strings = [ \"(name contains[cd] %@)\" ] * len ( text ) text_strings . extend ([ \"(plaintext contains[cd] %@)\" ] * len ( text )) format_strings . append ( text_strings ) if password_protected is not None and notes : password_string = ( [ \"(passwordProtected == TRUE)\" ] if password_protected else [ \"(passwordProtected == FALSE)\" ] ) format_strings . append ( password_string ) if id and notes : id_string = [ \"(id == %@)\" ] * len ( id ) format_strings . append ( id_string ) if format_strings : # have one or more search predicates; filter notes args = name or [] args += body or [] if text : args += text * 2 args += id or [] or_strings = [ \" OR \" . join ( strings ) for strings in format_strings ] format_str = \"(\" + \") AND (\" . join ( or_strings ) + \")\" predicate = AppKit . NSPredicate . predicateWithFormat_ ( format_str , * args ) notes = notes . filteredArrayUsingPredicate_ ( predicate ) return notes def _folder_for_name ( self , folder : str ) -> ScriptingBridge . SBObject : \"\"\"Return ScriptingBridge folder object for folder\"\"\" if folder_objs := self . _account . folders () . filteredArrayUsingPredicate_ ( AppKit . NSPredicate . predicateWithFormat_ ( \"name == %@\" , folder ) ): return folder_objs [ 0 ] else : raise ValueError ( f \"Could not find folder { folder } \" ) def _run_script ( self , script , * args ): return run_script ( script , self . name , * args ) def __len__ ( self ) -> int : \"\"\"Return count of notes\"\"\" return len ( self . _account . notes ()) # return self._run_script(\"accountGetCount\") def __iter__ ( self ) -> Generator [ Note , None , None ]: \"\"\"Generator to yield all notes contained in Notes.app\"\"\" for note in self . _account . notes (): yield Note ( note )","title":"Account"},{"location":"reference/#macnotesapp.notesapp.Account.default_folder","text":"Return name of default folder for account","title":"default_folder"},{"location":"reference/#macnotesapp.notesapp.Account.folders","text":"Return list of folder names in account","title":"folders"},{"location":"reference/#macnotesapp.notesapp.Account.id","text":"Return ID of account","title":"id"},{"location":"reference/#macnotesapp.notesapp.Account.name","text":"Return name of account","title":"name"},{"location":"reference/#macnotesapp.notesapp.Account.__init__","text":"Initialize Account object Source code in macnotesapp/notesapp.py 223 224 225 def __init__ ( self , account : ScriptingBridge . SBObject ): \"\"\"Initialize Account object\"\"\" self . _account = account","title":"__init__()"},{"location":"reference/#macnotesapp.notesapp.Account.__iter__","text":"Generator to yield all notes contained in Notes.app Source code in macnotesapp/notesapp.py 456 457 458 459 def __iter__ ( self ) -> Generator [ Note , None , None ]: \"\"\"Generator to yield all notes contained in Notes.app\"\"\" for note in self . _account . notes (): yield Note ( note )","title":"__iter__()"},{"location":"reference/#macnotesapp.notesapp.Account.__len__","text":"Return count of notes Source code in macnotesapp/notesapp.py 451 452 453 def __len__ ( self ) -> int : \"\"\"Return count of notes\"\"\" return len ( self . _account . notes ())","title":"__len__()"},{"location":"reference/#macnotesapp.notesapp.Account.folder","text":"Return Folder object for folder with name folder. Source code in macnotesapp/notesapp.py 332 333 334 335 def folder ( self , folder : str ) -> \"Folder\" : \"\"\"Return Folder object for folder with name folder.\"\"\" folder_obj = self . _folder_for_name ( folder ) return Folder ( folder_obj )","title":"folder()"},{"location":"reference/#macnotesapp.notesapp.Account.make_note","text":"Create new note in account Parameters: Name Type Description Default name str name of note required body str body of note required folder str | None optional folder to create note in; if None, uses default folder None attachments list [ str ] | None optional list of file paths to attach to note None Returns: Type Description 'Note' Note object for new note Raises: Type Description ScriptingBridgeError if note could not be created FileNotFoundError if attachment file could not be found Source code in macnotesapp/notesapp.py 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 def make_note ( self , name : str , body : str , folder : str | None = None , attachments : list [ str ] | None = None , ) -> \"Note\" : \"\"\"Create new note in account Args: name: name of note body: body of note folder: optional folder to create note in; if None, uses default folder attachments: optional list of file paths to attach to note Returns: Note object for new note Raises: ScriptingBridgeError: if note could not be created FileNotFoundError: if attachment file could not be found \"\"\" # reference: https://developer.apple.com/documentation/scriptingbridge/sbobject/1423973-initwithproperties notes_app = NotesApp () folder_obj = ( self . _folder_for_name ( folder ) if folder else self . _account . defaultFolder () ) properties = { \"body\" : f \"<div><h1> { name } </h1></div> \\n { body } \" , } note = ( notes_app . app . classForScriptingClass_ ( \"note\" ) . alloc () . initWithProperties_ ( properties ) ) notes = folder_obj . notes () len_before = len ( notes ) notes . addObject_ ( note ) len_after = len ( notes ) if len_after <= len_before : raise ScriptingBridgeError ( f \"Could not create note ' { name } ' with body ' { body } '\" ) new_note = Note ( note ) if attachments : for attachment in attachments : if not os . path . exists ( attachment ): raise FileNotFoundError ( f \"File { attachment } does not exist\" ) new_note . add_attachment ( attachment ) return new_note","title":"make_note()"},{"location":"reference/#macnotesapp.notesapp.Account.notes","text":"Return Note object for all notes contained in account or notes filtered by property. Parameters: Name Type Description Default name list [ str ] | None list of note names to filter by None body list [ str ] | None list of note bodies to filter by None text list [ str ] | None list of note text to filter by None password_protected bool | None filter by password protected notes None id list [ str ] | None list of note ids to filter by None Returns: Type Description list ['Note'] list of Note objects Source code in macnotesapp/notesapp.py 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def notes ( self , name : list [ str ] | None = None , body : list [ str ] | None = None , text : list [ str ] | None = None , password_protected : bool | None = None , id : list [ str ] | None = None , ) -> list [ \"Note\" ]: \"\"\"Return Note object for all notes contained in account or notes filtered by property. Args: name: list of note names to filter by body: list of note bodies to filter by text: list of note text to filter by password_protected: filter by password protected notes id: list of note ids to filter by Returns: list of Note objects \"\"\" # TODO: should this be a generator? notes = self . _account . notes () format_strings = [] if name and notes : name_strings = [ \"(name contains[cd] %@)\" ] * len ( name ) format_strings . append ( name_strings ) if body and notes : body_strings = [ \"(plaintext contains[cd] %@)\" ] * len ( body ) format_strings . append ( body_strings ) if text and notes : text_strings = [ \"(name contains[cd] %@)\" ] * len ( text ) text_strings . extend ([ \"(plaintext contains[cd] %@)\" ] * len ( text )) format_strings . append ( text_strings ) if password_protected is not None and notes : password_string = ( [ \"(passwordProtected == TRUE)\" ] if password_protected else [ \"(passwordProtected == FALSE)\" ] ) format_strings . append ( password_string ) if id and notes : id_string = [ \"(id == %@)\" ] * len ( id ) format_strings . append ( id_string ) if format_strings : # have one or more search predicates; filter notes args = name or [] args += body or [] if text : args += text * 2 args += id or [] or_strings = [ \" OR \" . join ( strings ) for strings in format_strings ] format_str = \"(\" + \") AND (\" . join ( or_strings ) + \")\" predicate = AppKit . NSPredicate . predicateWithFormat_ ( format_str , * args ) notes = notes . filteredArrayUsingPredicate_ ( predicate ) return [ Note ( note ) for note in notes . get ()]","title":"notes()"},{"location":"reference/#macnotesapp.notesapp.Account.noteslist","text":"Return NoteList object for all notes contained in account or notes filtered by property. Parameters: Name Type Description Default name list [ str ] | None list of note names to filter by None body list [ str ] | None list of note bodies to filter by None text list [ str ] | None list of note text to filter by None password_protected bool | None filter by password protected notes None id list [ str ] | None list of note ids to filter by None Returns: Type Description 'NotesList' NotesList object Source code in macnotesapp/notesapp.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 def noteslist ( self , name : list [ str ] | None = None , body : list [ str ] | None = None , text : list [ str ] | None = None , password_protected : bool | None = None , id : list [ str ] | None = None , ) -> \"NotesList\" : \"\"\"Return NoteList object for all notes contained in account or notes filtered by property. Args: name: list of note names to filter by body: list of note bodies to filter by text: list of note text to filter by password_protected: filter by password protected notes id: list of note ids to filter by Returns: NotesList object\"\"\" notes = self . _noteslist ( name , body , text , password_protected , id ) return NotesList ( notes )","title":"noteslist()"},{"location":"reference/#macnotesapp.notesapp.Account.show","text":"Show account in Notes.app UI Source code in macnotesapp/notesapp.py 337 338 339 def show ( self ): \"\"\"Show account in Notes.app UI\"\"\" self . _run_script ( \"accountShow\" )","title":"show()"},{"location":"reference/#folder","text":"Folder object Source code in macnotesapp/notesapp.py 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 class Folder : \"\"\"Folder object\"\"\" def __init__ ( self , folder : ScriptingBridge . SBObject ): self . _folder = folder @cached_property def id ( self ) -> str : \"\"\"ID of folder\"\"\" return ( str ( folder_id ) if ( folder_id := self . _folder . id ()) else str ( parse_id_from_object ( self . _folder . get ())) ) @property def name ( self ) -> str : \"\"\"Name of folder\"\"\" return str ( self . _folder . name ())","title":"Folder"},{"location":"reference/#macnotesapp.notesapp.Folder.id","text":"ID of folder","title":"id"},{"location":"reference/#macnotesapp.notesapp.Folder.name","text":"Name of folder","title":"name"},{"location":"reference/#note","text":"Note object representing a note in Notes.app Source code in macnotesapp/notesapp.py 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 class Note : \"\"\"Note object representing a note in Notes.app\"\"\" def __init__ ( self , note : ScriptingBridge . SBObject ): self . _note = note @property def account ( self ) -> str : \"\"\"Return name of account note belongs to.\"\"\" # can't determine this easily from the note object # so may to use AppleScript return str ( run_script ( \"noteGetAccount\" , self . id )) @cached_property def id ( self ) -> str : \"\"\"Return note ID\"\"\" if note_id := self . _note . id (): return str ( note_id ) else : # if note object created from selection or predicate it may show ID of 0 # but the ID is in the string representation of the object so parse it return parse_id_from_object ( self . _note ) or 0 @property def name ( self ) -> str : \"\"\"Return name of note\"\"\" return ( str ( name ) if ( name := self . _note . name ()) else self . _run_script ( \"noteGetName\" ) ) @name . setter def name ( self , name : str ): \"\"\"Set name of note\"\"\" self . _note . setValue_forKey_ ( name , \"name\" ) if self . name != name : self . _run_script ( \"noteSetName\" , name ) @property def body ( self ) -> str : \"\"\"Return body of note\"\"\" return ( str ( body ) if ( body := self . _note . body ()) else str ( self . _run_script ( \"noteGetBody\" )) ) @body . setter def body ( self , body : str ): \"\"\"Set body of note\"\"\" self . _note . setValue_forKey_ ( body , \"body\" ) if self . body != body : self . _run_script ( \"noteSetBody\" , body ) @property def plaintext ( self ) -> str : \"\"\"Return plaintext of note\"\"\" return ( str ( plaintext ) if ( plaintext := self . _note . plaintext ()) else str ( self . _run_script ( \"noteGetPlainText\" )) ) @property def creation_date ( self ) -> datetime : \"\"\"Return creation date of note as datetime\"\"\" if date := self . _note . creationDate (): return NSDate_to_datetime ( date ) else : return self . _run_script ( \"noteGetCreationDate\" ) @property def modification_date ( self ) -> datetime : \"\"\"Return modification date of note as datetime\"\"\" if date := self . _note . modificationDate (): return NSDate_to_datetime ( date ) else : return self . _run_script ( \"noteGetModificationDate\" ) @property def password_protected ( self ) -> bool : \"\"\"Return password protected status of note\"\"\" # return self._note.passwordProtected() # returns False even when note is password protected on some OS versions if MAC_OS_VERSION >= 13 : return bool ( self . _note . passwordProtected ()) return bool ( self . _run_script ( \"noteGetPasswordProtected\" )) @property def folder ( self ) -> str : \"\"\"Return name of folder note is contained in\"\"\" # calling container() method on note object returns None # in many cases, so use AppleScript instead return self . _note . container () . name () or self . _run_script ( \"noteGetContainer\" ) @property def attachments ( self ) -> list [ \"Attachment\" ]: \"\"\"Return list of attachments for note as Attachment objects\"\"\" # .attachments() method on note object sometimes returns duplicates, e.g each attachment is returned twice # filter out duplicates by comparing attachment ID # this appears to happen only with attachments added via AppleScript or ScriptingBridge # not with those natively added in Notes.app attachments = [ Attachment ( attachment ) for attachment in self . _note . attachments () ] return [ attachment for i , attachment in enumerate ( attachments ) if attachment . id not in [ a . id for a in attachments [: i ]] ] def add_attachment ( self , path : str ) -> \"Attachment\" : \"\"\"Add attachment to note Args: path: path to file to attach Returns: Attachment object for attached file Raises: FileNotFoundError: if file not found \"\"\" # Implementation note: # this is currently done with AppleScript which takes ~300ms on M1 Mac # it's faster with ScriptingBridge (~80ms) but when adding via ScriptingBridge # the attachment sometimes is added twice # See #15 for more details # must pass fully resolved path to AppleScript path = pathlib . Path ( path ) . expanduser () . resolve () if not path . exists (): raise FileNotFoundError ( f \"File not found: { path } \" ) attachment_id = self . _run_script ( \"noteAddAttachment\" , str ( path )) return Attachment ( self . _note . attachments () . objectWithID_ ( attachment_id )) def show ( self ): \"\"\"Show note in Notes.app UI\"\"\" self . _run_script ( \"noteShow\" ) def asdict ( self ) -> dict [ str , Any ]: \"\"\"Return dict representation of note\"\"\" return { \"account\" : self . account , \"id\" : self . id , \"name\" : self . name , \"body\" : self . body , \"plaintext\" : self . plaintext , \"creation_date\" : self . creation_date , \"modification_date\" : self . modification_date , \"password_protected\" : self . password_protected , \"folder\" : self . folder , } def _run_script ( self , script : str , * args ): \"\"\"Run AppleScript script\"\"\" return run_script ( script , self . account , self . id , * args ) def _parse_id_from_object ( self ) -> str : \"\"\"Parse the ID from the object representation when it can't be determined by ScriptingBridge\"\"\" # there are some conditions (e.g. using selection on Catalina or using a predicate) # where the ScriptingBridge sets the object ID to 0 # I haven't been able to figure out why but in this case, the id can be determined # by examining the string representation of the object which looks like this: # <SBObject @0x7fd721544690: <class ''> id \"x-coredata://19B82A76-B3FE-4427-9C5E-5107C1E3CA57/IMAPNote/p87\" of application \"Notes\" (55036)> if match := re . search ( r 'id \"(x-coredata://.+?)\"' , str ( self . _note )): return match [ 1 ] return None def __repr__ ( self ) -> str : return f \"Note( { self . id } )\" def __eq__ ( self , other : \"Note\" ): return ( self . id , self . account ) == ( other . id , other . account ) def __hash__ ( self ) -> int : return hash ( repr ( self ))","title":"Note"},{"location":"reference/#macnotesapp.notesapp.Note.account","text":"Return name of account note belongs to.","title":"account"},{"location":"reference/#macnotesapp.notesapp.Note.attachments","text":"Return list of attachments for note as Attachment objects","title":"attachments"},{"location":"reference/#macnotesapp.notesapp.Note.body","text":"Return body of note","title":"body"},{"location":"reference/#macnotesapp.notesapp.Note.creation_date","text":"Return creation date of note as datetime","title":"creation_date"},{"location":"reference/#macnotesapp.notesapp.Note.folder","text":"Return name of folder note is contained in","title":"folder"},{"location":"reference/#macnotesapp.notesapp.Note.id","text":"Return note ID","title":"id"},{"location":"reference/#macnotesapp.notesapp.Note.modification_date","text":"Return modification date of note as datetime","title":"modification_date"},{"location":"reference/#macnotesapp.notesapp.Note.name","text":"Return name of note","title":"name"},{"location":"reference/#macnotesapp.notesapp.Note.password_protected","text":"Return password protected status of note","title":"password_protected"},{"location":"reference/#macnotesapp.notesapp.Note.plaintext","text":"Return plaintext of note","title":"plaintext"},{"location":"reference/#macnotesapp.notesapp.Note.add_attachment","text":"Add attachment to note Parameters: Name Type Description Default path str path to file to attach required Returns: Type Description 'Attachment' Attachment object for attached file Raises: Type Description FileNotFoundError if file not found Source code in macnotesapp/notesapp.py 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 def add_attachment ( self , path : str ) -> \"Attachment\" : \"\"\"Add attachment to note Args: path: path to file to attach Returns: Attachment object for attached file Raises: FileNotFoundError: if file not found \"\"\" # Implementation note: # this is currently done with AppleScript which takes ~300ms on M1 Mac # it's faster with ScriptingBridge (~80ms) but when adding via ScriptingBridge # the attachment sometimes is added twice # See #15 for more details # must pass fully resolved path to AppleScript path = pathlib . Path ( path ) . expanduser () . resolve () if not path . exists (): raise FileNotFoundError ( f \"File not found: { path } \" ) attachment_id = self . _run_script ( \"noteAddAttachment\" , str ( path )) return Attachment ( self . _note . attachments () . objectWithID_ ( attachment_id ))","title":"add_attachment()"},{"location":"reference/#macnotesapp.notesapp.Note.asdict","text":"Return dict representation of note Source code in macnotesapp/notesapp.py 700 701 702 703 704 705 706 707 708 709 710 711 712 def asdict ( self ) -> dict [ str , Any ]: \"\"\"Return dict representation of note\"\"\" return { \"account\" : self . account , \"id\" : self . id , \"name\" : self . name , \"body\" : self . body , \"plaintext\" : self . plaintext , \"creation_date\" : self . creation_date , \"modification_date\" : self . modification_date , \"password_protected\" : self . password_protected , \"folder\" : self . folder , }","title":"asdict()"},{"location":"reference/#macnotesapp.notesapp.Note.show","text":"Show note in Notes.app UI Source code in macnotesapp/notesapp.py 696 697 698 def show ( self ): \"\"\"Show note in Notes.app UI\"\"\" self . _run_script ( \"noteShow\" )","title":"show()"},{"location":"reference/#noteslist","text":"NotesList object for list of notes. Represents an SBElementArray of notes as returned by noteslist() Source code in macnotesapp/notesapp.py 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 class NotesList : \"\"\"NotesList object for list of notes. Represents an SBElementArray of notes as returned by noteslist() \"\"\" def __init__ ( self , * noteslist : ScriptingBridge . SBElementArray ): self . _noteslist = noteslist @property def id ( self ) -> list [ str ]: \"\"\"Return ID of every note in list as list of strings\"\"\" return self . _apply_selector ( \"id\" ) @property def name ( self ) -> list [ str ]: \"\"\"Return name of every note in list as list of strings\"\"\" return self . _apply_selector ( \"name\" ) @property def body ( self ) -> list [ str ]: \"\"\"Return body of every note in list as list of strings\"\"\" return self . _apply_selector ( \"body\" ) @property def plaintext ( self ) -> list [ str ]: \"\"\"Return plaintext of every note in list as list of strings\"\"\" return self . _apply_selector ( \"plaintext\" ) @property def container ( self ) -> list [ str ]: \"\"\"Return container of every note in list as list of strings\"\"\" return self . _apply_selector ( \"container\" ) @property def folder ( self ) -> list [ str ]: \"\"\"Return folder of every note in list as list of strings\"\"\" return self . container @property def creation_date ( self ) -> list [ datetime ]: \"\"\"Return creation date of every note in list as list of datetimes\"\"\" return self . _apply_selector ( \"creationDate\" ) @property def modification_date ( self ) -> list [ datetime ]: \"\"\"Return modification date of every note in list as list of datetimes\"\"\" return self . _apply_selector ( \"modificationDate\" ) @property def password_protected ( self ) -> list [ bool ]: \"\"\"Return whether every note in list is password protected as list of bools\"\"\" return self . _apply_selector ( \"passwordProtected\" ) def asdict ( self ) -> list [ dict [ str , str ]]: \"\"\"Return list of dict representations of note\"\"\" return [ { \"id\" : note [ 0 ], \"name\" : note [ 1 ], \"body\" : note [ 2 ], \"plaintext\" : note [ 3 ], \"creation_date\" : note [ 4 ], \"modification_date\" : note [ 5 ], \"password_protected\" : note [ 6 ], \"folder\" : note [ 7 ], } for note in zip ( self . id , self . name , self . body , self . plaintext , self . creation_date , self . modification_date , self . password_protected , self . container , ) ] def _apply_selector ( self , selector ) -> list [ str ]: \"\"\"Return note properties in list that pass selector\"\"\" results_list = [] for noteslist in self . _noteslist : results = noteslist . arrayByApplyingSelector_ ( selector ) if selector in [ \"creationDate\" , \"modificationDate\" ]: results_list . extend ( NSDate_to_datetime ( date ) for date in results ) elif selector == \"container\" : results_list . extend ( str ( container . name ()) for container in results ) else : results_list . extend ([ str ( r ) for r in results ]) return results_list def __len__ ( self ) -> int : \"\"\"Return count of notes in list\"\"\" return len ( self . id )","title":"NotesList"},{"location":"reference/#macnotesapp.notesapp.NotesList.body","text":"Return body of every note in list as list of strings","title":"body"},{"location":"reference/#macnotesapp.notesapp.NotesList.container","text":"Return container of every note in list as list of strings","title":"container"},{"location":"reference/#macnotesapp.notesapp.NotesList.creation_date","text":"Return creation date of every note in list as list of datetimes","title":"creation_date"},{"location":"reference/#macnotesapp.notesapp.NotesList.folder","text":"Return folder of every note in list as list of strings","title":"folder"},{"location":"reference/#macnotesapp.notesapp.NotesList.id","text":"Return ID of every note in list as list of strings","title":"id"},{"location":"reference/#macnotesapp.notesapp.NotesList.modification_date","text":"Return modification date of every note in list as list of datetimes","title":"modification_date"},{"location":"reference/#macnotesapp.notesapp.NotesList.name","text":"Return name of every note in list as list of strings","title":"name"},{"location":"reference/#macnotesapp.notesapp.NotesList.password_protected","text":"Return whether every note in list is password protected as list of bools","title":"password_protected"},{"location":"reference/#macnotesapp.notesapp.NotesList.plaintext","text":"Return plaintext of every note in list as list of strings","title":"plaintext"},{"location":"reference/#macnotesapp.notesapp.NotesList.__len__","text":"Return count of notes in list Source code in macnotesapp/notesapp.py 553 554 555 def __len__ ( self ) -> int : \"\"\"Return count of notes in list\"\"\" return len ( self . id )","title":"__len__()"},{"location":"reference/#macnotesapp.notesapp.NotesList.asdict","text":"Return list of dict representations of note Source code in macnotesapp/notesapp.py 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 def asdict ( self ) -> list [ dict [ str , str ]]: \"\"\"Return list of dict representations of note\"\"\" return [ { \"id\" : note [ 0 ], \"name\" : note [ 1 ], \"body\" : note [ 2 ], \"plaintext\" : note [ 3 ], \"creation_date\" : note [ 4 ], \"modification_date\" : note [ 5 ], \"password_protected\" : note [ 6 ], \"folder\" : note [ 7 ], } for note in zip ( self . id , self . name , self . body , self . plaintext , self . creation_date , self . modification_date , self . password_protected , self . container , ) ]","title":"asdict()"},{"location":"reference/#attachment","text":"Notes.app Attachment object Source code in macnotesapp/notesapp.py 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 class Attachment : \"\"\"Notes.app Attachment object\"\"\" def __init__ ( self , attachment : ScriptingBridge . SBObject ): self . _attachment = attachment @cached_property def id ( self ) -> str : \"\"\"ID of attachment\"\"\" return str ( self . _attachment . id ()) @property def name ( self ) -> str : \"\"\"Name of attachment\"\"\" return str ( name ) if ( name := self . _attachment . name ()) else None @property def creation_date ( self ) -> datetime : \"\"\"Creation date of attachment\"\"\" return NSDate_to_datetime ( self . _attachment . creationDate ()) @property def modification_date ( self ) -> datetime : \"\"\"Modification date of attachment\"\"\" return NSDate_to_datetime ( self . _attachment . modificationDate ()) @property def content_identifier ( self ) -> str : \"\"\"The content-id URL in the note's HTML\"\"\" return str ( ci ) if ( ci := self . _attachment . contentIdentifier ()) else None @property def URL ( self ) -> str : \"\"\"For URL attachments, the URL the attachment represents\"\"\" return str ( url ) if ( url := self . _attachment . URL ()) else None def save ( self , path : str | bytes | os . PathLike ) -> str : \"\"\"Save attachment to file\"\"\" if not os . path . exists ( str ( path )): raise FileNotFoundError ( f \"Path does not exist: { path } \" ) url = AppKit . NSURL . alloc () . initFileURLWithPath_ ( os . path . join ( str ( path ), self . name ) ) self . _attachment . saveIn_as_ ( url , OSType ( \"item\" )) return str ( url . path ())","title":"Attachment"},{"location":"reference/#macnotesapp.notesapp.Attachment.URL","text":"For URL attachments, the URL the attachment represents","title":"URL"},{"location":"reference/#macnotesapp.notesapp.Attachment.content_identifier","text":"The content-id URL in the note's HTML","title":"content_identifier"},{"location":"reference/#macnotesapp.notesapp.Attachment.creation_date","text":"Creation date of attachment","title":"creation_date"},{"location":"reference/#macnotesapp.notesapp.Attachment.id","text":"ID of attachment","title":"id"},{"location":"reference/#macnotesapp.notesapp.Attachment.modification_date","text":"Modification date of attachment","title":"modification_date"},{"location":"reference/#macnotesapp.notesapp.Attachment.name","text":"Name of attachment","title":"name"},{"location":"reference/#macnotesapp.notesapp.Attachment.save","text":"Save attachment to file Source code in macnotesapp/notesapp.py 776 777 778 779 780 781 782 783 784 785 def save ( self , path : str | bytes | os . PathLike ) -> str : \"\"\"Save attachment to file\"\"\" if not os . path . exists ( str ( path )): raise FileNotFoundError ( f \"Path does not exist: { path } \" ) url = AppKit . NSURL . alloc () . initFileURLWithPath_ ( os . path . join ( str ( path ), self . name ) ) self . _attachment . saveIn_as_ ( url , OSType ( \"item\" )) return str ( url . path ())","title":"save()"}]}